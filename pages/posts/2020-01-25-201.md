---
title: Here We Go(relians) Again（HDOJ 2722）
date: 2020-01-25
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 最短路
tags:
  - C++
  - Dijkstra
  - 优先队列
---

<h2><strong>Problem Description</strong> </h2>
The Gorelians are a warlike race that travel the universe conquering new worlds as a form of recreation. Given their violent, fun-loving nature, keeping their leaders alive is of serious concern. Part of the Gorelian security plan involves changing the traffic patterns of their cities on a daily basis, and routing all Gorelian Government Officials to the Government Building by the fastest possible route.<br /><br />Fortunately for the Gorelian Minister of Traffic (that would be you), all Gorelian cities are laid out as a rectangular grid of blocks, where each block is a square measuring 2520 rels per side (a rel is the Gorelian Official Unit of Distance). The speed limit between two adjacent intersections is always constant, and may range from 1 to 9 rels per blip (a blip, of course, being the Gorelian Official Unit of Time). Since Gorelians have outlawed decimal numbers as unholy (hey, if you're the dominant force in the known universe, you can outlaw whatever you want), speed limits are always integer values. This explains why Gorelian blocks are precisely 2520 rels in length: 2520 is the least common multiple of the integers 1 through 9. Thus, the time required to travel between two adjacent intersections is always an integer number of blips.<br /><br />In all Gorelian cities, Government Housing is always at the northwest corner of the city, while the Government Building is always at the southeast corner. Streets between intersections might be one-way or two-way, or possibly even closed for repair (all this tinkering with traffic patterns causes a lot of accidents). Your job, given the details of speed limits, street directions, and street closures for a Gorelian city, is to determine the fastest route from Government Housing to the Government Building. (It is possible, due to street directions and closures, that no route exists, in which case a Gorelian Official Temporary Holiday is declared, and the Gorelian Officials take the day off.)

![](https://img.blueflame.org.cn/images/2021/03/07/8267cb5249c2.png)

The picture above shows a Gorelian City marked with speed limits, one way streets, and one closed street. It is assumed that streets are always traveled at the exact posted speed limit, and that turning a corner takes zero time. Under these conditions, you should be able to determine that the fastest route from Government Housing to the Government Building in this city is 1715 blips. And if the next day, the only change is that the closed road is opened to two way traffic at 9 rels per blip, the fastest route becomes 1295 blips. On the other hand, suppose the three one-way streets are switched from southbound to northbound (with the closed road remaining closed). In that case, no route would be possible and the day would be declared a holiday.

<h2><strong>Input</strong> </h2>

The input consists of a set of cities for which you must find a fastest route if one exists. The first line of an input case contains two integers, which are the vertical and horizontal number of city blocks, respectively. The smallest city is a single block, or 1 by 1, and the largest city is 20 by 20 blocks. The remainder of the input specifies speed limits and traffic directions for streets between intersections, one row of street segments at a time. The first line of the input (after the dimensions line) contains the data for the northernmost east-west street segments. The next line contains the data for the northernmost row of north-south street segments. Then the next row of east-west streets, then north-south streets, and so on, until the southernmost row of east-west streets. Speed limits and directions of travel are specified in order from west to east, and each consists of an integer from 0 to 9 indicating speed limit, and a symbol indicating which direction traffic may flow. A zero speed limit means the road is closed. All digits and symbols are delimited by a single space. For east-west streets, the symbol will be an asterisk '*' which indicates travel is allowed in both directions, a less-than symbol '<' which indicates travel is allowed only in an east-to-west direction, or a greater-than symbol '>' which indicates travel is allowed only in a west-to-east direction. For north-south streets, an asterisk again indicates travel is allowed in either direction, a lowercase "vee" character 'v' indicates travel is allowed only in a north-to-south directions, and a caret symbol '^' indicates travel is allowed only in a south-to-north direction. A zero speed, indicating a closed road, is always followed by an asterisk. Input cities continue in this manner until a value of zero is specified for both the vertical and horizontal dimensions.

<h2><strong>Output</strong> </h2>

For each input scenario, output a line specifying the integer number of blips of the shortest route, a space, and then the word "blips". For scenarios which have no route, output a line with the word "Holiday".

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">2 2
9 * 9 *
6 v 0 * 8 v
3 * 7 *
3 * 6 v 3 *
4 * 8 *
2 2
9 * 9 *
6 v 9 * 8 v
3 * 7 *
3 * 6 v 3 *
4 * 8 *
2 2
9 * 9 *
6 ^ 0 * 8 ^
3 * 7 *
3 * 6 ^ 3 *
4 * 8 *
0 0</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">1715 blips
1295 blips
Holiday</pre>

<h2>My Code</h2>

<p>这题就是输入麻烦了一点，后面就是最普通的单源最短路，这里我因为数组开小了，WA了两三小时。。。这题没什么特殊的数据，如果你也WA了，但怎么试都是对的话，不妨看看数组。。。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <queue>
#include <cstring>
#include <cstdio>
#define inf 0x3f3f3f3f
using namespace std;

int n, m, t;
char d;
struct edge
{
    int w;
    int v;
    int next;
} e[20010];
int tot;
int head[20010];
int dis[1050]; //数组要开到21*21以上，我在这卡了两小时。。。
bool vis[1050];
void add(int u, int v, int w)
{
    //cout << u << ' ' << v << ' ' << w << endl;
    e[++tot].v = v;
    e[tot].w = w;
    e[tot].next = head[u];
    head[u] = tot;
}
void dijkstra()
{
    priority_queue<pair<int, int>> q;
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, false, sizeof(vis));
    dis[0] = 0;
    q.push(make_pair(0, 0));
    while (q.size())
    {
        int p = q.top().second;
        q.pop();
        if (vis[p])
            continue;
        vis[p] = 1;
        for (int i = head[p]; i != 0; i = e[i].next)
        {
            if (dis[e[i].v] > dis[p] + e[i].w)
            {
                dis[e[i].v] = dis[p] + e[i].w;
                q.push(make_pair(-dis[e[i].v], e[i].v));
            }
        }
    }
}
int main()
{
    while (cin >> n >> m && n && m)
    {
        tot = 0;
        memset(head, 0, sizeof(head));
        for (int i = 0; i < 2 * n + 1; i++)
            for (int j = 0; j < m + i % 2; j++)
            {
                int k = (i / 2) * (m + 1) + j;  //这个可以自己对着图想象一下
                cin >> t >> d;                  //k是这条路的西或北点
                if (t == 0)         //速度0的直接跳过
                    continue;
                t = 2520 / t;
                if (d == '*')
                {
                    if (i % 2)
                    {
                        add(k, k + m + 1, t);
                        add(k + m + 1, k, t);
                    }
                    else
                    {
                        add(k, k + 1, t);
                        add(k + 1, k, t);
                    }
                }
                else if (d == '<')
                    add(k + 1, k, t);
                else if (d == '>')
                    add(k, k + 1, t);
                else if (d == 'v')
                    add(k, k + m + 1, t);
                else if (d == '^')
                    add(k + m + 1, k, t);
            }
        dijkstra();
        if (dis[(n + 1) * (m + 1) - 1] == inf)
            cout << "Holiday" << endl;
        else
            cout << dis[(n + 1) * (m + 1) - 1] << " blips" << endl;
    }
    return 0;
}</code></pre>

