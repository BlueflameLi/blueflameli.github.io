---
title: Choose the best route（HDOJ 2680）
date: 2020-01-23
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 最短路
tags:
  - C++
  - Dijkstra
  - 优先队列
---

<h2><strong>Problem Description</strong> </h2>

One day , Kiki wants to visit one of her friends. As she is liable to carsickness , she wants to arrive at her friend’s home as soon as possible . Now give you a map of the city’s traffic route, and the stations which are near Kiki’s home so that she can take. You may suppose Kiki can change the bus at any station. Please find out the least time Kiki needs to spend. To make it easy, if the city have n bus stations ,the stations will been expressed as an integer 1,2,3…n. 

<h2><strong>Input</strong> </h2>

There are several test cases.
Each case begins with three integers n, m and s,(n<1000,m<20000,1=<s<=n) n stands for the number of bus stations in this city and m stands for the number of directed ways between bus stations .(Maybe there are several ways between two bus stations .) s stands for the bus station that near Kiki’s friend’s home.
Then follow m lines ,each line contains three integers p , q , t (0<t<=1000). means from station p to station q there is a way and it will costs t minutes .
Then a line with an integer w(0<w<n), means the number of stations Kiki can take at the beginning. Then follows w integers stands for these stations.

<h2><strong>Output</strong> </h2>

The output contains one line for each data set : the least time Kiki needs to spend ,if it’s impossible to find such a route ,just output “-1”. </pre>

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">5 8 5
1 2 2
1 5 3
1 3 4
2 4 7
2 5 6
2 3 5
3 5 1
4 5 1
2
2 3
4 3 4
1 2 3
1 3 4
2 3 2
1
1</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">1
-1</pre>

<h2>My Code</h2>

<p>这题和<a href="https://blueflame.org.cn/program/c/hdoj-2066/">一个人的旅行（HDOJ 2066）</a>差不多，都是增加一个起点的起点使其变成单源最短路，不过这题终点只有一个，所以还可以采用反向存图的方法，将终点变成起点，这样也变成了单源最短路。这题数据量较大，用cin会TLE。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <queue>
#include <cstring>
#include <cstdio>
#define inf 0x3f3f3f3f
using namespace std;

int n, m, t, S, s;
struct edge
{
    int w;
    int v;
    int next;
} e[20010];
int tot;
int head[20010];
int dis[1005];
bool vis[1005];
void add(int u, int v, int w)
{
    e[++tot].v = v;
    e[tot].w = w;
    e[tot].next = head[u];
    head[u] = tot;
}
void dijkstra()
{
    priority_queue<pair<int, int>> q;
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, false, sizeof(vis));
    dis[0] = 0;
    q.push(make_pair(0, 0));
    while (q.size())
    {
        int p = q.top().second;
        q.pop();
        if (vis[p])
            continue;
        vis[p] = 1;
        for (int i = head[p]; i != 0; i = e[i].next)
        {
            if (dis[e[i].v] > dis[p] + e[i].w)
            {
                dis[e[i].v] = dis[p] + e[i].w;
                q.push(make_pair(-dis[e[i].v], e[i].v));
            }
        }
    }
}
int main()
{
    while (~scanf("%d%d%d",&n,&m,&t))       //cin会TLE
    {
        tot = 0;
        memset(head, 0, sizeof(head));
        for (int i = 0; i < m; i++)
        {
            int u, v, w;
            scanf("%d%d%d",&u,&v,&w);
            add(u, v, w);
        }
        scanf("%d",&S);
        for (int i = 0; i < S; i++)         //加一个起点的起点，这样就成单源最短路了
        {
            scanf("%d",&s);
            add(0, s, 0);
        }
        dijkstra();
        if (dis[t] == inf)
             printf("-1\n");
        else
            printf("%d\n",dis[t]);
    }
    return 0;
}</code></pre>
