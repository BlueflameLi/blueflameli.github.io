---
title: Arbitrage（HDOJ 1217）
date: 2020-01-21
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 最短路
tags:
  - C++
  - Floyd
---

<p>[info]今天开始进入第二专题了，这个专题应该是图论，我们将用到Floyd、dijkstra以及SPFA等熟悉的算法[/info]</p>

<h2> <strong>Problem Description</strong> </h2>

Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 * 10.0 * 0.21 = 1.05 US dollars, making a profit of 5 percent.

Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not. 

The input file will contain one or more test cases. Om the first line of each test case there is an integer n (1<=n<=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.
Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n.

<h2> <strong>Output</strong> </h2>

For each test case, print one line telling whether arbitrage is possible or not in the format "Case case: Yes" respectively "Case case: No". </pre>

<h2> <strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">3
USDollar
BritishPound
FrenchFranc
3
USDollar 0.5 BritishPound
BritishPound 10.0 FrenchFranc
FrenchFranc 0.21 USDollar

3
USDollar
BritishPound
FrenchFranc
6
USDollar 0.5 BritishPound
USDollar 4.9 FrenchFranc
BritishPound 10.0 FrenchFranc
BritishPound 1.99 USDollar
FrenchFranc 0.09 BritishPound
FrenchFranc 0.19 USDollar

0</pre>

<h2> <strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">Case 1: Yes
Case 2: No</pre>

<h2>My Code</h2>

<p>我感觉Floyd是图论里最简单的算法了，只需记得核心代码5行即可，为什么它不是Dijkstra呢，因为它是kij而不是ijk。</p>

<p>这里我主要是想学习一下map用法，这里我用了二维的map，map可以实现快速的查找和增减元素，用来当数组也很实用。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <algorithm>
#include <cstring>
#include <map>
using namespace std;
map<string, map<string, double>> ma;    //map二维
string s[50];
int n, m, t = 1;
void floyd() //floyd算法，很好记，kij，核心代码就五行
{
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (ma[s[i]][s[j]] < ma[s[i]][s[k]] * ma[s[k]][s[j]])
                    ma[s[i]][s[j]] = ma[s[i]][s[k]] * ma[s[k]][s[j]];
    for (int i = 1; i <= n; i++) //进行判断
        if (ma[s[i]][s[i]] > 1.0) //如果符合这个关系，说明能成立
        {
            cout << "Case " << t++ << ": "      //这边格式是vs code自动的，看着挺整齐
                 << "Yes" << endl;
            return;
        }
    cout << "Case " << t++ << ": "
         << "No" << endl;
}
int main()
{
    while (cin >> n && n != 0)
    {
        ma.clear();                      //清空
        for (int i = 1; i <= n; i++)
        {
            cin >> s[i]; //输入字符串
            ma[s[i]][s[i]] = 1.0;       //map是个好东西
        }
        cin >> m;
        double c;
        string a, b;
        for (int i = 1; i <= m; i++)
        {
            cin >> a >> c >> b;
            ma[a][b] = c;
        }
        floyd();
    }
    return 0;
}</code></pre>
