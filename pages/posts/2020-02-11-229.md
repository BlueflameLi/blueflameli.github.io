---
title: Machine Schedule（HDOJ 1150）
date: 2020-02-11
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 二分图
tags:
  - C++
  - DFS
  - 二分图
  - 匈牙利算法
---

## Problem Description 

As we all know, machine scheduling is a very classical problem in computer science and has been studied for a very long history. Scheduling problems differ widely in the nature of the constraints that must be satisfied and the type of schedule desired. Here we consider a 2-machine scheduling problem.

There are two machines A and B. Machine A has n kinds of working modes, which is called mode_0, mode_1, …, mode_n-1, likewise machine B has m kinds of working modes, mode_0, mode_1, … , mode_m-1. At the beginning they are both work at mode_0.

For k jobs given, each of them can be processed in either one of the two machines in particular mode. For example, job 0 can either be processed in machine A at mode_3 or in machine B at mode_4, job 1 can either be processed in machine A at mode_2 or in machine B at mode_4, and so on. Thus, for job i, the constraint can be represent as a triple (i, x, y), which means it can be processed either in machine A at mode_x, or in machine B at mode_y.

Obviously, to accomplish all the jobs, we need to change the machine's working mode from time to time, but unfortunately, the machine's working mode can only be changed by restarting it manually. By changing the sequence of the jobs and assigning each job to a suitable machine, please write a program to minimize the times of restarting machines. 

## Input 

The input file for this program consists of several configurations. The first line of one configuration contains three positive integers: n, m (n, m < 100) and k (k < 1000). The following k lines give the constrains of the k jobs, each line is a triple: i, x, y.

The input will be terminated by a line containing a single zero. 

## Output 

The output should be one integer per line, which means the minimal times of restarting machine. 

## Sample Input 

```
5 5 10
0 1 1
1 1 2
2 1 3
3 1 4
4 2 1
5 2 2
6 2 3
7 2 4
8 3 3
9 4 3
0
```

## Sample Output 

```
3 
```

## My Code

<p>这个专题是二分图，这道是比较典型的二分图最大匹配的变式——最小顶点覆盖，即用最少的点覆盖所有的路径，最小顶点覆盖数就等于最大匹配数。求最大匹配数很简单，我们采用匈牙利算法，其实就是dfs寻找增广路径，网上讲解挺多的，我这就不写了。<del>二分图一般用找对象来解释会比较形象。</del></p>

```cpp
#include <iostream>
#include <cstring>

using namespace std;
int n, m, k;
int linker[105];
bool map[105][105];
bool vis[105];
int cnt;

bool dfs(int u)
{
    for (int i = 1; i < m; i++)
        if (map[u][i] && !vis[i])
        {
            vis[i] = 1;
            if (linker[i] == -1 || dfs(linker[i]))   //如果i没有对象或者i的对象还能找到其他对象
            {                                        //那么u和i就匹配
                linker[i] = u;
                return true;
            }
        }
    return false;
}
void hungary()
{
    cnt = 0;
    memset(linker, -1, sizeof(linker));
    for (int i = 1; i < n; i++)
    {
        memset(vis, false, sizeof(vis));   //因为别人找过的对象你也还可以去试试，所以每次都要清空
        if (dfs(i))         //如果i能找到对象，匹配数++
            cnt++;
    }
}
int main()
{
    while (cin >> n && n)
    {
        cin >> m >> k;
        memset(map, false, sizeof(map));
        for (int i = 0; i < k; i++)
        {
            int id, u, v;
            cin >> id >> u >> v;
            if (u && v)       //一开始A和B都在mode_0，所以所有mode_0能完成的任务都不用管
                map[u][v] = 1;
        }

        hungary();
        cout << cnt << endl;
    }
}
```
