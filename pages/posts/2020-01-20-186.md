---
title: 逃离迷宫（HDOJ 1728）
date: 2020-01-20
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 搜索
tags:
  - C++
  - BFS
---

##  Problem Description

给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？

## Input　
  第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，  

&emsp;&emsp;第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符'.'表示该位置为空地，字符'*'表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub> (1 ≤ k ≤ 10, 1 ≤ x<sub>1</sub>, x<sub>2</sub> ≤ n, 1 ≤ y<sub>1</sub>, y<sub>2</sub> ≤ m),其中k表示gloria最多能转的弯数，(x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>)表示两个位置，其中x<sub>1</sub>，x<sub>2</sub>对应列，y<sub>1</sub>, y<sub>2</sub>对应行。

## Output　
每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。

## Sample Input 

```
2
5 5
...**
*.**.
.....
.....
*....
1 1 1 1 3
5 5
...**
*.**.
.....
.....
*....
2 1 1 1 3
```

## Sample Output 

```
no
yes
```

## My Code

```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
int n, m, t, k;
int a1, b1, a2, b2;        //因为y1之类的变量名有时候会函数冲突，所以我干脆改成了a1,b1这种
int dx[4] = {1, 0, -1, 0}; //方向
int dy[4] = {0, 1, 0, -1};
char map[105][105];
int v[105][105]; //标记一下，避免重复
struct node
{
    int x, y;
    int turn;      //记录转弯次数
} s;               //s是起始点
bool check(node p) //判断是否越界，是否有障碍
{
    if (p.x <= 0 || p.y <= 0)
        return false;
    if (p.x > n || p.y > m)
        return false;
    if (map[p.x][p.y] == '.')
        return true;
    if (p.x == b2 && p.y == a2)//别忘了x和y是反的
        return true;
    return false;
}
void bfs()
{
    queue<node> q;
    node p, e;
    memset(v, 0, sizeof(v)); //清空
    s.turn = -1;             //起点往任意方向都没有转弯
    q.push(s);               //起点入队，初始化要在入队前做
    v[s.x][s.y] = 1;
    while (!q.empty())
    {
        p = q.front();
        q.pop();
        //cout << p.x << ' ' << p.y << ' ' << p.turn << endl;
        if (p.turn >= k)
            continue; //转弯次数超了的，直接过
        for (int i = 0; i < 4; i++)
        {
            e.x = p.x + dx[i];
            e.y = p.y + dy[i];
            e.turn = p.turn + 1;
            //cout << p.x << ' ' << p.y << ' ' << e.x << ' ' << e.y << endl;
            while (check(e)) //因为尽量少拐弯，所以一直往一个方向冲就行了
            {

                if (e.x == b2 && e.y == a2)
                {
                    cout << "yes" << endl;
                    return;
                }
                if (!v[e.x][e.y])
                {
                    v[e.x][e.y] = 1;
                    q.push(e);
                }
                e.x += dx[i];
                e.y += dy[i]; //继续再这个方向上冲
            }
        }
    }
    cout << "no" << endl;
}
int main()
{

    cin >> t;
    while (t--)
    {
        cin >> n >> m;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                cin >> map[i][j];
        cin >> k >> a1 >> b1 >> a2 >> b2;      //注意k是第一个！！！
        s.x = b1;   //注意x和y是反的！！！
        s.y = a1;
        bfs();
    }
    return 0;
}
```

