---
title: 统计难题（HDOJ 1251）
date: 2020-01-29
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 字典树
tags:
  - C++
---

<h2><strong>Problem Description</strong> </h2>

Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). 

<h2><strong>Input</strong> </h2>

输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.

注意:本题只有一组测试数据,处理到文件结束.

对于每个提问,给出以该字符串为前缀的单词的数量.

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">banana
band
bee
absolute
acm

ba
b
band
abc</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">2
3
1
0</pre>

<h2>My Code</h2>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <cstring>
#include <string>
using namespace std;
struct Trie
{
    int next[30];           //用指针会MLE
    int v;
} tri[500005];              //一开始开1e6MLE了。。。
int tot = 1;
void creatTrie(string str)
{
    int p = 0, q;
    int l = str.length();
    for (int i = 0; i < l; i++)
    {
        int id = str[i] - 'a';
        if (tri[p].next[id] == 0)
        {
           tri[p].next[id] = tot;
           tot++;
        }
        p = tri[p].next[id];
        tri[p].v++;
    }
}
int findTrie(string str)
{
    int p = 0;
    int l = str.length();
    for (int i = 0; i < l; i++)
    {
        int id = str[i] - 'a';
        if (tri[p].next[id] == 0)
            return 0;
        p = tri[p].next[id];
    }
    return tri[p].v;
}
int main()
{
    string s;
    memset(tri, 0, sizeof(tri));
    while (getline(cin, s))
    {
        if (s.length() == 0)        //读到空行跳出
            break;
        creatTrie(s);
    }
    while (getline(cin, s))
        cout << findTrie(s) << endl;
    return 0;
}</code></pre>
