---
title: 最短路（HDOJ 2544）
date: 2020-01-23
updated: 2021-06-07
categories:
  - 程序人生
  - C/C++
  - 最短路
tags:
  - C++
  - Dijkstra
  - 优先队列
---

<h2><strong>Problem Description</strong> </h2>

在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？

输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。
输入保证至少存在1条商店到赛场的路线。

<h2><strong>Output</strong> </h2>

对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 </pre>

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">2 1
1 2 3
3 3
1 2 5
2 3 5
3 1 2
0 0</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">3
2</pre>

<h2>My Code</h2>

<p>这题可以算是单源最短路的模板题了，我的代码可以当作是dijkstra+堆优化的一个模板，在没有负边的情况下，dijkstra+堆优化绝对是最佳选择（数据大的时候记得改成scanf和printf，否则可能tle）</p>

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#define inf 0x3f3f3f3f
using namespace std;

int n, m, s;
struct edge
{
    int w;
    int v;
    int next;
} e[20010];
int tot;
int head[20010];
int dis[105];
bool vis[105];
void add(int u, int v, int w)
{
    e[++tot].v = v;
    e[tot].w = w;
    e[tot].next = head[u];
    head[u] = tot;
}
void dijkstra()
{
    priority_queue<pair<int, int>> q;
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, false, sizeof(vis));
    dis[1] = 0;
    q.push(make_pair(0, 1));
    while (q.size())
    {
        int p = q.top().second;
        q.pop();
        if (vis[p])
            continue;
        vis[p] = 1;
        for (int i = head[p]; i != 0; i = e[i].next)
        {
            if (dis[e[i].v] > dis[p] + e[i].w)
            {
                dis[e[i].v] = dis[p] + e[i].w;
                q.push(make_pair(-dis[e[i].v], e[i].v));
            }
        }
    }
}
int main()
{
    while (cin >> n >> m && n && m)
    {
        tot = 0;
        memset(head, 0, sizeof(head));
        for (int i = 0; i < m; i++)
        {
            int u, v, w;
            cin >> u >> v >> w;
            add(u, v, w);
            add(v, u, w);
        }
        dijkstra();
        cout << dis[n] << endl;
    }
    return 0;
}

```
