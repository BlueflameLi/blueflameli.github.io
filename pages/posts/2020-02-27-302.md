---
title: Just a Hook(HDOJ 1698)
date: 2020-02-27
updated: 2020-10-16
categories:
  - 程序人生
  - C/C++
  - 线段树
tags:
  - C++
  - 线段树
---


<h2><strong>Problem Description</strong> </h2>


<pre>In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.<br /><br /><img class="aligncenter" src="http://acm.hdu.edu.cn/data/images/C116-1010-1.JPG" /><br />Now Pudge wants to do some operations on the hook.<br /><br />Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.<br />The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:<br /><br />For each cupreous stick, the value is 1.<br />For each silver stick, the value is 2.<br />For each golden stick, the value is 3.<br /><br />Pudge wants to know the total value of the hook after performing the operations.<br />You may consider the original hook is made up of cupreous sticks.</pre>


<h2><strong>Input</strong> </h2>



<pre class="wp-block-preformatted">The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.
For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.
Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind. </pre>



<h2><strong>Output</strong> </h2>



<pre class="wp-block-preformatted">For each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example. </pre>



<h2><strong>Sample Input</strong> </h2>



<pre class="wp-block-preformatted">1
10
2
1 5 2
5 9 3</pre>



<h2><strong>Sample Output</strong> </h2>



<pre class="wp-block-preformatted">Case 1: The total value of the hook is 24.</pre>



<h2>My Code</h2>



<p>带延迟标记的线段树的模板题了吧，延迟标记主要用于大量的区间更新时，更新的区间越大效率越高，单点更新的话，就没有什么用了</p>



<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include &lt;iostream>
#include &lt;cstring>
#include &lt;cstdio>
#define maxn 100000 + 5
using namespace std;

struct node
{
    int v;      //区间和
    int l;      //区间边界
    int r;
    int len;    //区间长度
    int lazy;   //延迟标记
} tree[maxn &lt;&lt; 2];//要开四倍大小

int t, n, q;
int cnt;

void pushup(int p)//子节点更新完，向上更新父节点
{
    tree[p].v = tree[p &lt;&lt; 1].v + tree[p &lt;&lt; 1 | 1].v;
}
void build(int l, int r, int p)
{
    tree[p].l = l;      //初始化
    tree[p].r = r;
    tree[p].len = r - l + 1;
    tree[p].lazy = 0;

    if (l == r)
    {
        tree[p].v = 1;  //初始为铜
        return;
    }

    int m = (l + r) >> 1;

    build(l, m, p &lt;&lt; 1);
    build(m + 1, r, p &lt;&lt; 1 | 1);

    pushup(p);          //切记向上更新
}
void pushdown(int p)//将延迟标记推下去
{
    if (tree[p].lazy)
    {
        tree[p &lt;&lt; 1].v = tree[p].lazy * tree[p &lt;&lt; 1].len;//更新子节点
        tree[p &lt;&lt; 1 | 1].v = tree[p].lazy * tree[p &lt;&lt; 1 | 1].len;

        tree[p &lt;&lt; 1].lazy = tree[p &lt;&lt; 1 | 1].lazy = tree[p].lazy; //延迟标记推下去
        tree[p].lazy = 0;           //记得去掉当前节点的延迟标记
    }
}
void update(int l, int r, int z, int p)
{
    if (l &lt;= tree[p].l &amp;&amp; tree[p].r &lt;= r)   //若当前区间包含于查询区间
    {
        tree[p].v = z * tree[p].len;        //更新区间和和延迟标记
        tree[p].lazy = z;
        return;
    }

    pushdown(p);    //先将延迟标记推下去，更新子节点

    int m = (tree[p].l + tree[p].r) >> 1;

    if (l &lt;= m)
        update(l, r, z, p &lt;&lt; 1);
    if (r > m)
        update(l, r, z, p &lt;&lt; 1 | 1);
    pushup(p);      //向上更新
}

int main()
{
    ios::sync_with_stdio(false);//数据较大，用scanf或者关同步
    cout.tie(NULL);
    cin >> t;
    while (t--)
    {
        cin >> n;
        build(1, n, 1);

        cin >> q;
        while (q--)
        {
            int x, y, z;
            cin >> x >> y >> z;
            update(x, y, z, 1);
        }
        //因为输出整段的和，所以不许要另外的函数了，直接输出即可
        cout &lt;&lt; "Case " &lt;&lt; ++cnt &lt;&lt; ": The total value of the hook is " &lt;&lt; tree[1].v &lt;&lt; "." &lt;&lt; endl;
    }
    return 0;
}</code></pre>
