---
title: 敌兵布阵（HDOJ 1166）
date: 2020-02-20
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 树状数组
  - 程序人生
  - C/C++
  - 线段树
tags:
  - C++
---

<h2><strong>Problem Description</strong> </h2>

C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。
中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说："我知错了。。。"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. 

<h2><strong>Input</strong> </h2>

第一行一个整数T，表示有T组数据。
每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。
接下来每行有一条命令，命令有4种形式：
(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）
(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;
(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数;
(4)End 表示结束，这条命令在每组数据最后出现;
每组数据最多有40000条命令 

<h2><strong>Output</strong> </h2>

对第i组数据,首先输出“Case i:”和回车,
对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 </pre>

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">1
10
1 2 3 4 5 6 7 8 9 10
Query 1 3
Add 3 6
Query 2 7
Sub 10 2
Add 6 3
Query 3 10
End </pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">Case 1:
6
33
59</pre>

<h2>My Code</h2>

<p>树状数组的模板题，涉及区间查询和单点修改的题比较适合用树状数组来做。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
using namespace std;

int t, n, a[50005];
int cnt;
int lowbit(int x)       //取x的最低位的1，利用了负数补码的性质
{
    return x & -x;
}
void update(int x, int v)   //更新x节点的值
{
    while (x <= n)
    {
        a[x] += v;
        x += lowbit(x);
    }
}
int sum(int x)      //x的前缀和
{
    int ans = 0;
    while (x)
    {
        ans += a[x];
        x -= lowbit(x);
    }
    return ans;
}
int main()
{
    cin >> t;
    while (t--)
    {
        memset(a, 0, sizeof(a));
        cin >> n;
        for (int i = 1; i <= n; i++)
        {
            int x;
            cin >> x;
            update(i, x);       //初始都是0，直接加上去就行了，不需要另外建
        }
        cout << "Case " << ++cnt << ":" << endl;
        string str;
        while (cin >> str)
        {
            if (str == "End")
                break;
            if (str == "Query")
            {
                int l, r;
                cin >> l >> r;
                cout << sum(r) - sum(l - 1) << endl;        //l到r的和就是r的前缀和减去l-1的前缀和
            }
            else if (str == "Add")
            {
                int i, j;
                cin >> i >> j;
                update(i, j);
            }
            else if (str == "Sub")
            {
                int i, j;
                cin >> i >> j;
                update(i, -j);          //减去只要加上一个负数即可
            }
        }
    }
    return 0;
}</code></pre>

<p>下面是线段树版的代码，线段树相对来讲区间修改的效率更高些，这题效率比树状数组低一些。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <cstring>
#include <cstdio>
#define maxn 50005

using namespace std;

struct node
{
    int v;              //这题的单点修改，不需要lazy标记
    int l;
    int r;
} tree[maxn << 2];      //要开正常大小的四倍
int a[maxn];
int t;
int n;
int cnt;
void build_tree(int l, int r, int id)
{
    tree[id].l = l;
    tree[id].r = r;
    if (l == r)
    {
        tree[id].v = a[l];
        return;
    }
    int m = (l + r) >> 1;       //位运算速度更快
    build_tree(l, m, id << 1);
    build_tree(m + 1, r, id << 1 | 1);
    tree[id].v = tree[id << 1].v + tree[id << 1 | 1].v; //向上更新
}

int sum(int l, int r, int id)
{
    if (tree[id].l > r || tree[id].r < l)   //超出范围
        return 0;
    if (l <= tree[id].l && tree[id].r <= r)     //当前区间包含于查询区间，返回整个区间
        return tree[id].v;

    int m = (tree[id].l + tree[id].r) >> 1;
    return sum(l, r, id << 1) + sum(l, r, id << 1 | 1);
}
void update(int i, int v, int id)
{
    if (tree[id].l == tree[id].r)
    {
        tree[id].v += v;
        return;
    }

    int m = (tree[id].l + tree[id].r) >> 1;
    if (i <= m)
        update(i, v, id << 1);
    else
        update(i, v, id << 1 | 1);
    tree[id].v = tree[id << 1].v + tree[id << 1 | 1].v;
}
int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &n);
        cout << "Case " << ++cnt << ":" << endl;
        for (int i = 1; i <= n; i++)
            scanf("%d", &a[i]); //数据量较大用scanf
        build_tree(1, n, 1);
        string str;
        while (cin >> str)
        {
            if (str == "End")
                break;
            if (str == "Query")
            {
                int l, r;
                scanf("%d%d", &l, &r);
                printf("%d\n", sum(l, r, 1));
            }
            else if (str == "Add")
            {
                int i, v;
                scanf("%d%d", &i, &v);
                update(i, v, 1);
            }
            else
            {
                int i, v;
                scanf("%d%d", &i, &v);
                update(i, -v, 1);
            }
        }
    }
    return 0;
}</code></pre>
