---
title: Einbahnstrasse（HDOJ 2923）
date: 2020-01-25
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 最短路
tags:
  - C++
  - Floyd
---

## Problem Description 

Einbahnstra ![](https://img.blueflame.org.cn/images/2021/03/07/21c268c020a5.jpg)e (German for a one-way street) is a street on which vehicles should only move in one direction. One reason for having one-way streets is to facilitate a smoother flow of traffic through crowded areas. This is useful in city centers, especially old cities like Cairo and Damascus. Careful planning guarantees that you can get to any location starting from any point. Nevertheless, drivers must carefully plan their route in order to avoid prolonging their trip due to one-way streets. Experienced drivers know that there are multiple paths to travel between any two locations. Not only that, there might be multiple roads between the same two locations. Knowing the shortest way between any two locations is a must! This is even more important when driving vehicles that are hard to maneuver (garbage trucks, towing trucks, etc.)

You just started a new job at a car-towing company. The company has a number of towing trucks parked at the company's garage. A tow-truck lifts the front or back wheels of a broken car in order to pull it straight back to the company's garage. You receive calls from various parts of the city about broken cars that need to be towed. The cars have to be towed in the same order as you receive the calls. Your job is to advise the tow-truck drivers regarding the shortest way in order to collect all broken cars back in to the company's garage. At the end of the day, you have to report to the management the total distance traveled by the trucks.

## Input 

Your program will be tested on one or more test cases. The first line of each test case specifies three numbers (N , C , and R ) separated by one or more spaces. The city has N locations with distinct names, including the company's garage. C is the number of broken cars. R is the number of roads in the city. Note that 0 < N < 100 , 0<=C < 1000 , and R < 10000 . The second line is made of C + 1 words, the first being the location of the company's garage, and the rest being the locations of the broken cars. A location is a word made of 10 letters or less. Letter case is significant. After the second line, there will be exactly R lines, each describing a road. A road is described using one of these three formats:


A -v -> B
A <-v - B
A <-v -> B


A and B are names of two different locations, while v is a positive integer (not exceeding 1000) denoting the length of the road. The first format specifies a one-way street from location A to B , the second specifies a one-way street from B to A , while the last specifies a two-way street between them. A , ``the arrow", and B are separated by one or more spaces. The end of the test cases is specified with a line having three zeros (for N , C , and R .)

The test case in the example below is the same as the one in the figure.

![](https://img.blueflame.org.cn/images/2021/03/07/e0fcb40ad17a.jpg)

## Output 

For each test case, print the total distance traveled using the following format:

k . V

Where k is test case number (starting at 1,) is a space, and V is the result. 

## Sample Input 

```
4 2 5
NewTroy Midvale Metrodale
NewTroy   <-20-> Midvale
Midvale   --50-> Bakerline
NewTroy    <-5-- Bakerline
Metrodale <-30-> NewTroy
Metrodale  --5-> Bakerline
0 0 0
```

## Sample Output 

```
1. 80 
```

## My Code

<p>这题两个点，一个是字符串的处理，一个就是拖车是去一个点，回一次起点，去一个，回一次起点的（来回的路不一定一样）。</p>

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <map>
#define inf 0x3f3f3f3f
using namespace std;

int n, c, r;
string e[1005];
int cnt;
int tot = 0;
int dis[200][200];
map<string, int> StoI; //通过map将地名编号，转化成int
void floyd()
{
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
            {
                if (dis[i][j] > dis[i][k] + dis[k][j])
                    dis[i][j] = dis[i][k] + dis[k][j];
            }
}
int main()
{
    while (cin >> n >> c >> r)
    {
        if (n == 0 && c == 0 && r == 0)
            break;
        tot++;
        cnt = 0;
        StoI.clear();
        memset(dis, 0x3f, sizeof(dis));
        for (int i = 0; i <= n; i++)
            dis[i][i] = 0;
        for (int i = 0; i <= c; i++)
        {
            cin >> e[i];
            if (!StoI.count(e[i]))
                StoI[e[i]] = ++cnt;
        }
        for (int i = 0; i < r; i++)
        {
            string u, w, v;
            cin >> u >> w >> v;
            if (!StoI.count(u))
                StoI[u] = ++cnt;
            if (!StoI.count(v))
                StoI[v] = ++cnt;
            int l = w.length();
            int x = 0;
            for (int j = 2; j < l - 2; j++)
                x = x * 10 + w[j] - '0';            //判重边
            if (dis[StoI[v]][StoI[u]] > x && w[0] == '<')
                dis[StoI[v]][StoI[u]] = x;
            if (dis[StoI[u]][StoI[v]] > x && w[l - 1] == '>')
                dis[StoI[u]][StoI[v]] = x;
        }
        floyd();
        int ans = 0;
        for (int i = 1; i <= c; i++)        //每次都要把车拖回来
            ans += dis[StoI[e[0]]][StoI[e[i]]]+dis[StoI[e[i]]][StoI[e[0]]];
        cout << tot << ". " << ans << endl;
    }
    return 0;
}
```
