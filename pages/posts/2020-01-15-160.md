---
title: Nightmare（HDOJ 1072）
date: 2020-01-15
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 搜索
tags:
  - C++
  - BFS
---

<p>[info]由于寒假要做专题训练，所以我决定，把代码都记录下来，这是第一题，是一道bfs，由此可见这个专题应该都是搜索了，唉，心累。[/info]</p>

## Problem Description 

Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.

Given the layout of the labyrinth and Ignatius' start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.

Here are some rules:

1. We can assume the labyrinth is a 2 array.
2. Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.
3. If Ignatius get to the exit when the exploding time turns to 0, he can't get out of the labyrinth.
4. If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can't use the equipment to reset the bomb.
5. A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.
6. The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.

## Input 

The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.
Each test case starts with two integers N and M(1<=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.
There are five integers which indicate the different type of area in the labyrinth:
0: The area is a wall, Ignatius should not walk on it.
1: The area contains nothing, Ignatius can walk on it.
2: Ignatius' start position, Ignatius starts his escape from this position.
3: The exit of the labyrinth, Ignatius' target position.
4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.

## Output 

For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1. 

## Sample Input

```
3
3 3
2 1 1
1 1 0
1 1 3
4 8
2 1 1 0 1 1 1 0
1 0 4 1 1 0 4 1
1 0 0 0 0 0 0 1
1 1 1 4 1 1 1 3
5 8
1 2 1 1 1 1 1 4 
1 0 0 0 1 0 0 1 
1 4 1 0 1 1 0 1 
1 0 0 0 0 3 0 1 
1 1 4 1 1 1 1 1 
```

## Sample Output 

```
4
-1
13
```

## My Code

```cpp
#include<iostream>
#include<queue>
using namespace std;
int t;
int n, m;
int r = 6;
int dx[4] = { 0,1,-1,0 };			//dx和dy两个数组控制方向
int dy[4] = { 1,0,0,-1 };
int map[10][10];					//将迷宫的地图存下来
struct node
{
	int x, y;						//x和y是坐标
	int time;						//剩余时间
	int step;						//步数
}s;									//s是起始点

void bfs()
{
	queue<node> q;
	q.push(s);						//将起始点入队
	node next, p;
	while (!q.empty())
	{
		p = q.front();				//队首是p
		q.pop();					//出队
		if (p.time == 1)			//如果时间只剩1分钟了还没到终点或者重置点，那么就挂了
			continue;
		for (int i = 0; i < 4; i++)
		{
			next.x = p.x + dx[i];	//计算下一个点next的坐标
			next.y = p.y + dy[i];
			//cout << next.x <<' '<< next.y<<endl;
			if (next.x >= 0 && next.x < n && next.y>=0 && next.y < m && map[next.x][next.y])
			{											//如果没有越界且不是墙就走
				next.time = p.time - 1;					//时间减少一分钟
				next.step = p.step + 1;					//步数加1
				if (map[next.x][next.y] == 4)			//到达重置点
				{
					next.time = 6;						//时间重置
					map[next.x][next.y] = 0;			//既然每次到达重置点时间都剩下6分钟，
				}										//那么显然后面再来重置点没有意义，肯定不是最短路线
				q.push(next);							//下一个点进队
			}
			if (map[next.x][next.y] == 3)				//到终点了，输出步数，退出
			{
				cout << next.step << endl;
				return;
			}
		}
	}
	cout << -1 << endl;			//队列都空了还没找到终点，挂了

}
int main()
{
	cin >> t;
	while (t--)
	{
		cin >> n >> m;
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
			{
				cin >> map[i][j];
				if (map[i][j] == 2)
				{
					s.x = i;		//起始点初始化
					s.y = j;
					s.time = 6;
					s.step = 0;
				}
			}
		bfs();
	}
	return 0;
}
```
