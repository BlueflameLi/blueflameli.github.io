---
title: Air Raid（HDOJ 1151）
date: 2020-02-11
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 二分图
tags:
  - C++
  - DFS
  - 二分图
  - 匈牙利算法
---

## Problem Description 

Consider a town where all the streets are one-way and each street leads from one intersection to another. It is also known that starting from an intersection and walking through town's streets you can never reach the same intersection i.e. the town's streets form no cycles.

With these assumptions your task is to write a program that finds the minimum number of paratroopers that can descend on the town and visit all the intersections of this town in such a way that more than one paratrooper visits no intersection. Each paratrooper lands at an intersection and can visit other intersections following the town streets. There are no restrictions about the starting intersection for each paratrooper. 

## Input 

Your program should read sets of data. The first line of the input file contains the number of the data sets. Each data set specifies the structure of a town and has the format:

no_of_intersections
no_of_streets
S1 E1
S2 E2
......
Sno_of_streets Eno_of_streets

The first line of each data set contains a positive integer no_of_intersections (greater than 0 and less or equal to 120), which is the number of intersections in the town. The second line contains a positive integer no_of_streets, which is the number of streets in the town. The next no_of_streets lines, one for each street in the town, are randomly ordered and represent the town's streets. The line corresponding to street k (k <= no_of_streets) consists of two positive integers, separated by one blank: Sk (1 <= Sk <= no_of_intersections) - the number of the intersection that is the start of the street, and Ek (1 <= Ek <= no_of_intersections) - the number of the intersection that is the end of the street. Intersections are represented by integers from 1 to no_of_intersections.

There are no blank lines between consecutive sets of data. Input data are correct. 

## Output 

The result of the program is on standard output. For each input data set the program prints on a single line, starting from the beginning of the line, one integer: the minimum number of paratroopers required to visit all the intersections in the town. 

## Sample Input 

```
2
4
3
3 4
1 3
2 3
3
3
1 3
1 2
2 3
```

## Sample Output 

```
2
1
```

## My Code

<p>这题就上一题稍微改一下就好了，还是二分图匹配，不过比较隐晦，这题是求最小路径覆盖，即选最少的路径覆盖所有顶点，这里证明怎么证的我也不太清楚，只需要记住结论，最小路径覆盖数等于顶点数减去最大匹配数，所以还是匈牙利算法求最大匹配。这里还有个关键就是构造二分图，假设路的起点是1~n，终点是1'~n'，这样就是二分图了，但其实n和n'是一样的。</p>

```cpp
#include <iostream>
#include <cstring>

using namespace std;
int t, n, m, k;
int linker[150];
bool map[150][150];
bool vis[150];
int cnt;

bool dfs(int u)
{
    for (int i = 1; i <= n; i++)
        if (map[u][i] && !vis[i])
        {
            vis[i] = 1;
            if (linker[i] == -1 || dfs(linker[i])) //如果i没有对象或者i的对象还能找到其他对象
            {                                      //那么u和i就匹配
                linker[i] = u;
                return true;
            }
        }
    return false;
}
void hungary()
{
    cnt = 0;
    memset(linker, -1, sizeof(linker));
    for (int i = 1; i <= n; i++)
    {
        memset(vis, false, sizeof(vis)); //因为别人找过的对象你也还可以去试试，所以每次都要清空
        if (dfs(i))                      //如果i能找到对象，匹配数++
            cnt++;
    }
}
int main()
{
    cin >> t;
    while (t--)
    {
        cin >> n >> m;
        memset(map, false, sizeof(map));
        for (int i = 0; i < m; i++)
        {
            int u, v;
            cin >> u >> v;              //构造二分图，起点是1~n，终点是1'~n'
            map[u][v] = 1;
        }

        hungary();
        cout << n - cnt << endl;        //最小路径覆盖数等于顶点数-最大匹配数
    }
}
```
