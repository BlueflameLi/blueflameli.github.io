---
title: Rescue（HDOJ 1242）
date: 2020-01-20
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 搜索
tags:
  - C++
  - BFS
---

## Problem Description 

Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M <= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.

Angel's friends want to save Angel. Their task is: approach Angel. We assume that "approach Angel" is to get to the position where Angel stays. When there's a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.

You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) 

First line contains two integers stand for N and M. Then N lines follows, every line has M characters. "." stands for road, "a" stands for Angel, and "r" stands for each of Angel's friend. Process to the end of the file. 

## Output 

For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing "Poor ANGEL has to stay in the prison all his life."

## Sample Input 

```
7 8
#.#####.
#.a#..r.
#..#x...
..#..#.#
#...##..
.#......
........
```

## Sample Output 

```
13
```

## My Code

```cpp
#include <iostream>  
#include <queue>  
#include<cstring>
using namespace std;

int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };
char map[205][205];
int v[205][205];
int n, m;
struct node
{
    int x, y, step;
    friend bool operator < (node a, node b) //优先队列默认是大根堆
    {                                       //若a.step>b.step为真
        return a.step > b.step;             //则a<b,b排在a的前面
    }                                       //这样step小的就排在前面了
}s;                                       
bool check(node p)
{
    if (p.x < 0 || p.y < 0)
        return false;
    if (p.x >= n || p.y >= m)
        return false;
    if (map[p.x][p.y] == '#')
        return false;
    if (v[p.x][p.y])
        return false;
    return true;
}
void bfs()
{
    memset(v, 0,sizeof(v));
    priority_queue<node> q;     //建立优先队列  
    node p, next;
    v[s.x][s.y] = 1;
    q.push(s);
    while (!q.empty())
    {
        p = q.top();
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            next.x = p.x + dx[i];
            next.y = p.y + dy[i];
            if (check(next))
            {
                if (map[next.x][next.y] == 'x')
                    next.step = p.step + 2; //遇到X时间加2  
                else
                    next.step = p.step + 1;   //否则正常加1 
                if (map[next.x][next.y] == 'r')  //因为有多个朋友，不好处理
                {                                //所以逆向，天使找到一个朋友就算得救了
                    cout << next.step << endl;
                    return;
                }
                v[next.x][next.y] = 1;
                q.push(next);
            }
        }
    }
    cout << "Poor ANGEL has to stay in the prison all his life." << endl;
}
int main()
{
    while (cin >> n >> m)
    {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
            {
                cin >> map[i][j];
                if (map[i][j] == 'a')
                {
                    s.x = i;
                    s.y = j;
                    s.step = 0;
                }
            }
        bfs();
    }

    return 0;
}
```
