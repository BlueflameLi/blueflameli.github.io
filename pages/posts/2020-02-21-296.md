---
title: Color the ball(HDOJ 1556)
date: 2020-02-21
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 树状数组
tags:
  - C++
  - 差分
---

<h2><strong>Problem Description</strong> </h2>

N个气球排成一排，从左到右依次编号为1,2,3....N.每次给定2个整数a b(a <= b),lele便为骑上他的“小飞鸽"牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？ 

<h2><strong>Input</strong> </h2>

每个测试实例第一行为一个整数N,(N <= 100000).接下来的N行，每行包括2个整数a b(1 <= a <= b <= N)。
当N = 0，输入结束。 

<h2><strong>Output</strong> </h2>

每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。 </pre>

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">3
1 1
2 2
3 3
3
1 1
1 2
1 3
0</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">1 1 1
3 2 1</pre>

<h2>My Code</h2>

<p>区间修改和大量单点查询，如果只用普通的树状数组，那么效率还不如普通数组。所有需要用到差分数组。若原数组为a[]，那么新的数组c[i]=a[i]-a[i-1]。这样修改一个点c[i]，就相当于修改了原来的a[i]到a[n]，修改一个区间[l,r]，只需要修改c[l]和c[r+1]即可。而差分数组的前缀和sum(i)，就是原先的a[i]。通过差分数组，就将区间修改和单点查询转化为了树状数组高效的单点修改和区间查询。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>

using namespace std;

int a[100005];      //树状数组的差分数组，a[i]表示原树状数组c[i]-c[i-1];
int n;
int lowbit(int x)
{
    return x & -x;
}
void add(int x, int v)
{
    while (x <= n)
    {
        a[x] += v;
        x += lowbit(x);
    }
}
int sum(int x)
{
    int ans = 0;
    while (x > 0)
    {
        ans += a[x];
        x -= lowbit(x);
    }
    return ans;
}
int main()
{
    while (cin >> n && n)
    {
        memset(a, 0, sizeof(a));
        for (int i = 0; i < n; i++)
        {
            int l, r;
            cin >> l >> r;
            add(l, 1);              //差分数组l点加1相当于原l之后的所有点加1
            add(r + 1, -1);         //r+1点减1，相当于原r+1点之后所有点减1，即实现[l,r]加1
        }
        cout << sum(1);
        for (int i = 2; i <= n; i++)
            cout << ' ' << sum(i);    //差分数组前缀和sum(i)就是原数组c[i]点的值
        cout << endl;
    }
    return 0;
}</code></pre>
