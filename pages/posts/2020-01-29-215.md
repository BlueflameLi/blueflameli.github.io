---
title: Immediate Decodability（HDOJ 1305）
date: 2020-01-29
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 字典树
tags:
  - C++
---

<p>[info]又到了新的专题，这专题的内容是字典树[/info]</p>

<h2><strong>Problem Description</strong> </h2>

An encoding of a set of symbols is said to be immediately decodable if no code for one symbol is the prefix of a code for another symbol. We will assume for this problem that all codes are in binary, that no two codes within a set of codes are the same, that each code has at least one bit and no more than ten bits, and that each set has at least two codes and no more than eight.

Examples: Assume an alphabet that has symbols {A, B, C, D}

The following code is immediately decodable:
A:01 B:10 C:0010 D:0000

but this one is not:
A:01 B:10 C:010 D:0000 (Note that A is a prefix of C) 

Write a program that accepts as input a series of groups of records from input. Each record in a group contains a collection of zeroes and ones representing a binary code for a different symbol. Each group is followed by a single separator record containing a single 9; the separator records are not part of the group. Each group is independent of other groups; the codes in one group are not related to codes in any other group (that is, each group is to be processed independently).

For each group, your program should determine whether the codes in that group are immediately decodable, and should print a single output line giving the group number and stating whether the group is, or is not, immediately decodable. </pre>

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">01
10
0010
0000
9
01
10
010
0000
9</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">Set 1 is immediately decodable
Set 2 is not immediately decodable</pre>

<h2>My Code</h2>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <cstring>

using namespace std;
struct Trie
{
    Trie *next[2];
    int v;
} * root;
int tot;
void creatTrie(string str)      //建树
{
    Trie *p = root, *q;
    int l = str.length();
    for (int i = 0; i < l; i++)
    {
        int id = str[i] - '0';
        if (p->next[id] == NULL)
        {
            q = new Trie;      //创建一个新节点
            q->next[0] = q->next[1] = NULL;
            q->v = 1;
            p->next[id] = q;
        }
        p = p->next[id]; 
    }
    p->v = -1;                  //标记结束点
}
bool findTrie(string str)       //找前缀
{
    Trie *p = root;
    int l = str.length();
    for (int i = 0; i < l; i++)
    {
        int id = str[i] - '0';
        if (i < l - 1 && p->next[id]->v == -1)
            return true;
        p = p->next[id];
    }
    return 0;
}
int main()
{
    string s[10];
    while (cin >> s[0])
    {
        root = new Trie;        //创建根节点
        root->next[0] = root->next[1] = NULL;
        root->v = 1;
        creatTrie(s[0]);
        int k = 1;
        while (cin >> s[k] && s[k][0] != '9')
            creatTrie(s[k++]);
        bool f = 0;
        for (int i = 0; i < k; i++)
            if (findTrie(s[i]))
            {
                cout << "Set " << ++tot << " is not immediately decodable" << endl;
                f = 1;
                break;
            }
        if (!f)
            cout << "Set " << ++tot << " is immediately decodable" << endl;
    }
    return 0;
}</code></pre>
