---
title: In Action（HDOJ 3339）
date: 2020-01-25
updated: 2021-03-07
categories:
  - 程序人生
  - C/C++
  - 最短路
tags:
  - C++
  - Floyd
---

<h2><strong>Problem Description</strong> </h2>

![](https://img.blueflame.org.cn/images/2021/03/07/e5ff37ab6314.jpg)
Since 1945, when the first nuclear bomb was exploded by the Manhattan Project team in the US, the number of nuclear weapons have soared across the globe.<br />Nowadays,the crazy boy in FZU named AekdyCoin possesses some nuclear weapons and wanna destroy our world. Fortunately, our mysterious spy-net has gotten his plan. Now, we need to stop it.<br />But the arduous task is obviously not easy. First of all, we know that the operating system of the nuclear weapon consists of some connected electric stations, which forms a huge and complex electric network. Every electric station has its power value. To start the nuclear weapon, it must cost half of the electric network's power. So first of all, we need to make more than half of the power diasbled. Our tanks are ready for our action in the base(ID is 0), and we must drive them on the road. As for a electric station, we control them if and only if our tanks stop there. 1 unit distance costs 1 unit oil. And we have enough tanks to use.<br />Now our commander wants to know the minimal oil cost in this action.

The first line of the input contains a single integer T, specifying the number of testcase in the file.
For each case, first line is the integer n(1<= n<= 100), m(1<= m<= 10000), specifying the number of the stations(the IDs are 1,2,3...n), and the number of the roads between the station(bi-direction).
Then m lines follow, each line is interger st(0<= st<= n), ed(0<= ed<= n), dis(0<= dis<= 100), specifying the start point, end point, and the distance between.
Then n lines follow, each line is a interger pow(1<= pow<= 100), specifying the electric station's power by ID order. 

<h2><strong>Output</strong> </h2>

The minimal oil cost in this action.
If not exist print "impossible"(without quotes).

<h2><strong>Sample Input</strong> </h2>

<pre class="wp-block-preformatted">2
2 3
0 2 9
2 1 3
1 0 2
1
3
2 1
2 1 3
1
3</pre>

<h2><strong>Sample Output</strong> </h2>

<pre class="wp-block-preformatted">5
impossible</pre>

<h2>My Code</h2>

<p>这题就是最短路+01背包，01背包核心代码就三行，一个正循环套一个倒循环。</p>

<pre class="wp-block-code"><code lang="cpp" class="language-cpp line-numbers">#include <iostream>
#include <cstring>
#define inf 0x3f3f3f3f
using namespace std;

int map[105][105];
int f[1000000];
int a[105];
int t, n, m;
int u, v, w;
void Floyd()
{
    for (int k = 0; k <= n; k++)
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= n; j++)
                if (map[i][j] > map[i][k] + map[k][j])
                    map[i][j] = map[i][k] + map[k][j];
}

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        memset(f, inf, sizeof(f));              //因为是要油耗尽量小，所以初始赋无穷大
        cin >> n >> m;
        memset(map, 0x3f, sizeof(map));
        for (int i = 0; i <= n; i++)
            map[i][i] = 0;
        for (int i = 0; i < m; i++)
        {
            cin >> u >> v >> w;
            if (map[u][v] > w)
                map[u][v] = map[v][u] = w;
        }
        int sum = 0;
        for (int i = 1; i <= n; i++)
        {
            cin >> a[i];
            sum += a[i];                            //以总电力sum来作为背包容量
        }
        Floyd();
        f[0] = 0;
        for (int i = 1; i <= n; i++)
            for (int j = sum; j >= a[i]; j--)       //以到每个点的最短距离作为东西的价值
                f[j] = min(f[j], f[j - a[i]] + map[0][i]);  //这里是要价值也就是油耗尽可能小，所以是min
        int k = sum / 2 + 1;
        int ans = inf;
        for (int i = sum; i >= k; i--)
        {
            ans = min(ans, f[i]);
        }
        if (ans == inf)
            cout << "impossible" << endl;
        else
            cout << ans << endl;
    }
    return 0;
}</code></pre>
